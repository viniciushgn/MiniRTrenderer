#version 330 core
out vec2 FragColor; in vec2 vUV; // classic splitâ€‘sum LUT approx (very compact)
float radicalInverse_VdC(uint bits){ bits = (bits<<16u) | (bits>>16u); bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u); bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u); bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u); bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u); return float(bits) * 2.3283064365386963e-10; }
vec2 Hammersley(uint i, uint N){ return vec2(float(i)/float(N), radicalInverse_VdC(i)); }
vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float a){ float phi = 2.0*3.14159265*Xi.x; float cosTheta = sqrt((1.0-Xi.y)/(1.0+(a*a-1.0)*Xi.y)); float sinTheta = sqrt(1.0-cosTheta*cosTheta); vec3 H = vec3(cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta); vec3 up = abs(N.z)<0.999? vec3(0,0,1):vec3(1,0,0); vec3 T = normalize(cross(up,N)); vec3 B = cross(N,T); return normalize(T*H.x + B*H.y + N*H.z); }
float G_Smith(float NoV, float NoL, float a){ float k=(a*a)/2.0; float GL=NoL/(NoL*(1.0-k)+k); float GV=NoV/(NoV*(1.0-k)+k); return GL*GV; }
vec2 IntegrateBRDF(float NoV, float rough){ vec3 V = vec3(sqrt(1.0-NoV*NoV), 0.0, NoV); float a=rough*rough; float A=0.0, B=0.0; const uint SAMPLE_COUNT=1024u; for(uint i=0u;i<SAMPLE_COUNT;++i){ vec2 Xi=Hammersley(i,SAMPLE_COUNT); vec3 H=ImportanceSampleGGX(Xi, vec3(0,0,1), a); vec3 L=normalize(2.0*dot(V,H)*H - V); float NoL = max(L.z,0.0); float NoH = max(H.z,0.0); float VoH = max(dot(V,H),0.0); if(NoL>0.0){ float G = G_Smith(NoV,NoL,a); float G_Vis = (G*VoH)/(NoH*NoV+1e-5); float Fc = pow(1.0-VoH,5.0); A += (1.0-Fc)*G_Vis; B += Fc*G_Vis; } } A/=float(SAMPLE_COUNT); B/=float(SAMPLE_COUNT); return vec2(A,B); }
void main(){ vec2 brdf = IntegrateBRDF(vUV.x, vUV.y); FragColor=brdf; }